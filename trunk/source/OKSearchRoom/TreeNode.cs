///////////////////////////////////////////////////////////
//  TreeNode.cs
//  Implementation of the Class Node
//  Generated by Enterprise Architect
//  Created on:      29-Jul-2006 18:36:24
//  Original author: Oliver Kuehne
///////////////////////////////////////////////////////////




using OKSearchRoom;
using System.Collections.Generic;
using System.Collections;
using System;
namespace OKSearchRoom {
	/// <summary>
	/// Diese Klasse dient der Umsetzung eines Baumes. Jedes Objekt dieser Klasse
	/// repräsentiert einen Knoten in einem Baum.
    /// <remarks>
    /// Alle Knoten sind über Eltern-Kind-Verknüpfungen miteinander verbunden.
    /// </remarks>
	/// </summary>
    public class TreeNode : Node
    {
        #region "class TreeNodeCollection"

		/// <summary>
		/// Stellt eine Kollektion zur Verfügung, um die Kindknoten eines Knotens zu
		/// verwalten.
		/// </summary>
        public class TreeNodeCollection : IEnumerable
        {
            /// <summary>
            /// Enthält eine Liste von Knoten
            /// </summary>
            protected List<TreeNode> _list;
            /// <summary>
            /// Enthält den Elternknoten.
            /// </summary>
            protected TreeNode _parent;

			/// <summary>
			/// Konstruktor
			/// </summary>
			/// <param name="parent">Der Elternknoten.</param>
            public TreeNodeCollection(TreeNode parent)
            {
                _parent = parent;
                _list = new List<TreeNode>();
            }

            /// <summary>
			/// Ein Suchraumknoten wird hinzugefügt. Die Suchtiefe sowie der Elternknoten des
			/// übergebenen Knotens werden akualisiert.
			/// </summary>
			/// <param name="item">Knoten, der hinzugefügt wird.</param>
            public virtual void Add(TreeNode item)
            {
                if (item.Parent != null)
                    throw new Exception("The node to add has already a parent");
                item._parent = _parent;
                item._depth = _parent._depth + 1;
                item._children.UpdateDepth(item._depth + 1);
                _list.Add(item);
            }

			/// <summary>
			/// Entfernt alle Unterknoten.
			/// </summary>
            public virtual void Clear()
            {
                foreach (TreeNode item in _list)
                {
                    item.Clear();
                }
                _list.Clear();
            }

            /// <summary>
			/// Überprüft, ob der übergebene Knoten schon in der Collection enthalten ist. Wenn
			/// ja wird true zurückgegben, sonst false.
			/// </summary>
			/// <param name="item">Knoten, der auf Enthaltung geprüft wird.</param>
            public virtual bool Contains(TreeNode item)
            {
                return _list.Contains(item);
            }

			/// <summary>
			/// Gibt die Anzahl der Knoten ,die in der Collection enthalten sind, an.
			/// </summary>
            public int Count
            {
                get{return _list.Count;}
            }

            /// <summary>
			/// Gibt den Index innerhalb der Collection vom übergebenen Knoten zurück. Ist der
			/// Knoten nicht enthalten wird -1 zurückgegeben.
			/// </summary>
			/// <param name="item">Knoten, dessen Index ermittelt werden soll.</param>
            public virtual int IndexOf(TreeNode item)
            {
                return _list.IndexOf(item);
            }

            /// <summary>
			/// Entfernt einen Knoten aus der Collection.
			/// </summary>
			/// <param name="item">Der Knoten, der entfernt werden soll.</param>
            public virtual void Remove(TreeNode item)
            {
                RemoveAt(_list.IndexOf(item));
            }

            /// <summary>
			/// Entfernt den Knoten an der übergebenen Position.
			/// </summary>
			/// <param name="index">Der Index, an dem ein Knoten entfernt wird.</param>
            public virtual void RemoveAt(int index)
            {
                TreeNode delItem = _list[index];
                foreach (TreeNode item in delItem._children)
                {
                    Insert(index, item);
                    index++;
                }
                _list[index]._children.Clear();
                _list[index]._parent = null;
                _list.RemoveAt(index);
            }

			/// <summary>
			/// Fügt einen Knoten an einer bestimmten Position ein.
			/// </summary>
			/// <param name="index">Der Index, wo der Knoten eingefügt wird.</param>
			/// <param name="item">Der Knoten, der eingefügt werden soll.</param>
            public virtual void Insert(int index, TreeNode item)
            {
                if (item._parent != null)
                    throw new Exception("The node to add has already a parent");
                item._parent = _parent;
                item._depth = _parent._depth + 1;
                item._children.UpdateDepth(item._depth + 1);
                _list.Insert(index, item);
            }

			/// <summary>
			/// Liefert oder setzt den Knoten an der angegebenen Position.
			/// </summary>
			/// <param name="index">Der Index.</param>
            public TreeNode this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    _list[index]._children.Clear();
                    RemoveAt(index);
                    Insert(index, value);
                }
            }

			/// <summary>
			/// Liefert einen Enumerator zurück.
			/// </summary>
            public virtual IEnumerator GetEnumerator()
            {
                return _list.GetEnumerator();
            }

			/// <summary>
			/// Aktualisiert für alle Knoten der Collection die Suchtiefe mit dem übergebenen
			/// Wert. Auch die Unterknoten der Collection werden davon ausgehend aktualisiert.
			/// </summary>
			/// <param name="depth">Die Suchtiefe.</param>
            private void UpdateDepth(int depth)
            {
                foreach (TreeNode node in _list)
                {
                    node._depth = depth;
                    node.Children.UpdateDepth(depth + 1);
                }
            }

        }//end TreeNodeCollection
        #endregion

        #region Protected Member
        /// <summary>
        /// Enthält Referenzen auf alle Kinder dieses Knotens
        /// </summary>
        protected TreeNodeCollection _children;
        /// <summary>
        /// Enthält die Referenz auf den Vater dieses Knotens oder null
        /// </summary>
		protected TreeNode _parent;
        #endregion

        #region Constructor
        /// <summary>
		/// Der Konstruktor.
		/// </summary>
        public TreeNode() : base()
		{
            _children = new TreeNodeCollection(this);
            _parent = null;
		}

		/// <summary>
		/// Der Konstruktor bei dem das übergebene Objekt in den zu erzeugenen Knoten
		/// eingebettet wird.
		/// </summary>
		/// <param name="data">Das einzubettende Objekt</param>
        public TreeNode(object data) : base(data)
        {
            _children = new TreeNodeCollection(this);
            _parent = null;
        }

		/// <summary>
		/// Der Konstruktor bei dem der erzeugte Knoten gleich zu einem Unterknoten des
		/// übergebenen Elternknotens wird. Das übergebene Objekt wird eingebettet.
		/// </summary>
		/// <param name="parent">Der Elternknoten</param>
		/// <param name="data">Das einzubettende Objekt.</param>
        public TreeNode(TreeNode parent, object data): base(parent, data)
        {
            _children = new TreeNodeCollection(this);
            parent.Children.Add(this);
        }
        #endregion

        #region Public Member
        /// <summary>
		/// Liefert alle Unterknoten.
		/// </summary>
		public TreeNodeCollection Children{
			get{
				return _children;
			}
		}

		/// <summary>
		/// Gibt den Elternknoten zurück. Stellt dieser Knoten die Wurzel eines Baumes dar,
		/// wird null zurückgegeben.
		/// </summary>
		public TreeNode Parent{
			get{
				return _parent;
			}
        }
        #endregion

        #region Public Functions
        /// <summary>
        /// Renitialisiert den Knoten
        /// </summary>
        public override void Clear()
        {
            Children.Clear();
            _parent = null;
            _depth = 0;
        }
        #endregion

    }//end TreeNode

}//end namespace OKSearchRoom