///////////////////////////////////////////////////////////
//  DepthFirstSearch.cs
//  Implementation of the Class DepthFirstSearch
//  Generated by Enterprise Architect
//  Created on:      29-Jul-2006 18:36:23
//  Original author: Oliver Kuehne
///////////////////////////////////////////////////////////




using System.Collections.Generic;
using OKSearchRoom;
using System;
namespace OKSearchRoom {
	/// <summary>
	/// Mit dieser Klasse ist es möglich, auf einem Suchbaum eine Tiefensuche
	/// durchzuführen. 
    /// <remarks>
    /// Diese Suche kann unendlich lange dauern, wenn die Suchtiefe eines
	/// Zweiges des entstehenden Suchbaums unendlich ist. Alle aktuell zu
	/// untersuchenden Knoten werden als Knotenmenge gehalten.
    /// </remarks>
	/// </summary>
	public class DepthFirstSearch : SearchMethod
    {
        #region Protected Member
        /// <summary>
        /// Enthält die Knotenmenge in Form eines Stacks, der für LastIn FirstOut am besten geeignet ist.
        /// </summary>
        protected Stack<INode> _nodes;
        #endregion

        #region Constructor
        /// <summary>
		/// Der Konstruktor, dem ein Suchproblem übergeben wird.
		/// </summary>
		/// <param name="searchProblem"></param>
		public DepthFirstSearch(ISearchProblem searchProblem): base(searchProblem)
		{
            _nodes = new Stack<INode>();
        }
        #endregion

        #region Protected Functions
        /// <summary>
		/// Auswahl des nächsten zu untersuchenden Knotens.
		/// </summary>
		protected bool ChooseNode()
		{
            if (_nodes.Count > 0)
            {
                _currentNode = _nodes.Pop();
                _inspectedNodes++;
                return true;
            }
            return false;
		}

		/// <summary>
		/// Der Suchbaum wird geleert, nur die Wurzel bleibt erhalten.
		/// </summary>
		protected override void Init()
		{
            _cancel = false;
            _inspectedNodes = 0;
            _nodes.Clear();
            INode[] nodes = _searchProblem.FirstNodes;
            foreach (INode node in nodes)
            {
                node.Clear();
                _nodes.Push(node);
            }
            if (_nodes.Count == 0)
                throw new Exception("There are no first nodes");
		}

		/// <summary>
		/// Der Suchalgorithmus wird gestartet. Er kann nur beendet werden, indem innerhalb
		/// der Methode des Eventhandlers Cancel auf true gesetzt wird. Sonst endet die
		/// Suche mit dem Finden des Zielknotens, oder nach erfolglosem Absuchen des
		/// gesamten Suchraums.
		/// </summary>
        protected override void Search()
        {
            INode[] generatedNodes;
            while (ChooseNode())
            {
                if (_searchProblem.CompareNodes(_currentNode))
                {
                    if (_searchProblem.OnFoundDestination(_currentNode, this))
                        return;
                    else
                        continue;
                }
                generatedNodes = _searchProblem.GenerateChildren(_currentNode, 0);
                foreach (INode node in generatedNodes)
                {
                    _nodes.Push(node);
                }
                EmitSearchEvent(_nodes.Count);
                if (_cancel)
                {
                    _searchProblem.OnFoundNoneDestination();
                    return;
                }
            }
            _searchProblem.OnFoundNoneDestination();
        }
        #endregion

        #region Public Functions
        /// <summary>
        /// Gibt die Knotenmenge zurück oder setzt diese
        /// </summary>
        public override IEnumerable<INode> NodeSet
        {
            get
            {
                return _nodes;
            }
            set
            {
                _nodes = new Stack<INode>(value);
            }
        }
        #endregion

    }//end DepthFirstSearch

}//end namespace OKSearchRoom